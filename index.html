<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Panele</title>
<!-- <link rel="stylesheet" href="css.css"> 
<!-- <script src="js.js" type="text/javascript"></script> -->
<style>
body {
    font-family: Arial, sans-serif;
    background-color: #f8f8f8;
    vertical-align: middle;
    
}


#roof {
    border: 1px solid #000;
    position: relative;
}



.panel {
    position: absolute;
    border: 1px solid #444;
    background-color: #ddd;
}

#material-summary {
    margin-top: 20px;
    padding: 10px;
    border: 0px solid #000;
    background-color: #f8f8f8;
}

#info {
    margin-top: 20px;
    padding: 10px;
    border: 0px solid #000;
    background-color: #f8f8f8;
}

#infoDiv {
    margin-top: 20px;
    padding: 10px;
    border: 0px solid #000;
    background-color: #f8f8f8;

}

.roww${row}-container {
    margin-right: 10px; /* Odstęp między boxami */
    border: 1px solid black; /* Opcjonalna ramka dla wizualizacji boxów */
    padding: 5px; /* Odstęp wewnątrz boxu */
}


h3 {
    color: #333;
}

p {
    color: #666;
}

.panel {
    transition: background-color 0.5s, transform 0.5s;
}




/* Styles for the profile checkbox */
#profile-checkbox {
    margin-top: 10px;
}

/* Additional styling improvements can go here */

.button1 {
    margin-top: 20px;
    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.05), 0 6px 20px 0 rgba(0,0,0,0.03);
    size: 30px;
    padding: 10px 24px;
	margin-bottom: 20px;
  }


   #roof {
      position: relative;
      border: 4px solid #000;
      margin-top: 20px;
      background-color: #c7c7c7;
      box-shadow: 0 8px 16px 0 rgba(0,0,0,0.5), 0 2px 40px 0 rgba(0,0,0,0.03);
    }

    .panel {
      position: absolute;
      border: 2px solid #ccc;
      cursor: pointer;
    }

    #elo {
        position: relative;
    }
    
    #elo::before {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        top: 50%;
        border-top: 1px solid black;
        transform: translateY(-50%);
    }


    
    #elo {
        transform: scale(0.95); /* Slightly enlarge selected panels */
        border: 1px solid black;
        position:absolute;
        z-index: 1000;
        background-color: rgb(21, 0, 156);
        color: darkslateblue;
    }


    #elo {
        position: absolute;
        height: 100px; /* Dostosuj wysokość według potrzeb */
        background: linear-gradient(
            to right,
            black 0, black 1px, /* pierwsza linia */
            rgb(0, 47, 148) 1px, rgb(0, 47, 148) 24%, /* przeźroczysty odstęp */
            black 24%, black 26%, /* druga linia */
            rgb(0, 47, 148) 26%, rgb(0, 47, 148) 49%, /* przeźroczysty odstęp */
            black 49%, black 51%, /* trzecia linia */
            rgb(0, 47, 148) 51%, rgb(0, 47, 148) 74%, /* przeźroczysty odstęp */
            black 74%, black 76%, /* czwarta linia */
            rgb(0, 47, 148) 72%, rgb(0, 47, 148) 99% /* przeźroczysty odstęp do końca */
        );
    }
    
    #elo::before {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        top: 50%;
        height: 1px; /* Grubość linii poziomej */
        background-color: rgb(0, 0, 0);
    }
    

	div {
	font-size:24px;
	font-family: Calibri;
	}
	
	input {
	
                    padding: 7px;
                    border-radius: 6px;
                    font-size: 16px;
                    background: #fbfbfb;
                    border: 2px solid transparent;
                    height: 12px;
					//width: 90%;
                    box-shadow: 0 0 0 1px #000000, 0 2px 4px 0 rgb(0 0 0 / 7%), 0 1px 1.5px 0 rgb(0 0 0 / 5%);
                }
				
				
</style>


</head>

<body>
  
  <center>

    <table>
      <tr>
        <th><label for="roof-size-vertical">Wysokość dachu:</label></th>
        <th><label for="roof-size-horizontal">Szerokość dachu:</label></th>
        <th><label for="panel-size-width">Szerokość panela:</label></th>
        <th><label for="panel-size-height">Wysokość panela:</label></th>
      </tr>
      <tr>
        <th><input type="number" id="roof-size-vertical" placeholder="522.6"></td>
        <td><input type="number" id="roof-size-horizontal" placeholder="1617.6"></td>
        <td><input type="number" id="panel-size-width" placeholder="113.4"></td>
        <td><input type="number" id="panel-size-height" placeholder="172.2"></td>
      </tr>
    </table>
    
    <button class ="button1" id="calculate">Oblicz</button>
	    <button class ="button1" id="calculate">download</button>

	<select id="material-selection-dropdown">
    <option value="dach-profile" selected>Dach profile</option>
    <option value="mostki">Mostki</option>
</select>

	
	<section id="profile-selection">
  <label><input type="checkbox" id="profile-354" name="profile" value="354" checked> 354cm</label>
  <label><input type="checkbox" id="profile-240" name="profile" value="240" checked> 240cm</label></br>
  <label><input type="checkbox" id="profile-177" name="profile" value="177" checked> 177cm</label>
  <label><input type="checkbox" id="profile-120" name="profile" value="120" checked> 120cm</label></br>
</section>
<div id="swap-dimensions">
  <label><input type="checkbox" id="swap-dimensions-checkbox" >Poziomo</label>
</div>


    <div id="roof"></div>
    
    <div id="info"></div>
    <div id="overall-summary"></div>
    <div id="infoDiv"></div>
  
    
  
<footer id="footer">

</footer>
  </center>
<script>
let profileCalculations = []; // Global variable for profile calculations	
let summaryDiv = document.getElementById('material-summary');
document.addEventListener('DOMContentLoaded', function() {
  const swapCheckbox = document.getElementById('swap-dimensions-checkbox');
  const roof = document.getElementById('roof');
  const roofSizeVerticalInput = document.getElementById('roof-size-vertical');
  const roofSizeHorizontalInput = document.getElementById('roof-size-horizontal');
  const panelSizeWidthInput = document.getElementById('panel-size-width');
  const panelSizeHeightInput = document.getElementById('panel-size-height');
  const calculateButton = document.getElementById('calculate');
  const profileButton = document.getElementById('profile-calculation');
  const infoDiv = document.getElementById('info');
  const summaryDiv = document.getElementById('infoDiv');
  const ssDiv = document.getElementById('overall-summary');

function roundToTwo(num) {
    return +(Math.round(num + "e+2")  + "e-2");
}


  let panelWidth = 113.4;
  let panelHeight = 172.2;
  let dom_szer = 1617.6;
  let dom_wys = 522.6;
  const panelGap = 2;
  const maxPanels = 362;
  let selectedPanels = [];
  let pw = panelWidth;
	let ph = panelHeight;

  swapCheckbox.addEventListener('change', function() {
    if (this.checked) {
      // Zamiana wartości wysokości i szerokości
      panelHeight = pw;
      panelWidth = ph;
      obliczanie();
    } else {
      panelHeight = ph;
      panelWidth = pw;
      obliczanie();
    }
  });




  function obliczanie() {
    const roofSizeVertical = parseFloat(roofSizeVerticalInput.value) || dom_wys; //Wysokość
    const roofSizeHorizontal = parseFloat(roofSizeHorizontalInput.value) || dom_szer; //Szerokość
    panelWidth = parseFloat(panelSizeWidthInput.value) || panelWidth;
    panelHeight = parseFloat(panelSizeHeightInput.value) || panelHeight;

    const panelsCountVertical = Math.floor(roofSizeVertical / (panelHeight + panelGap));
    const panelsCountHorizontal = Math.floor(roofSizeHorizontal / (panelWidth + panelGap));
    const totalPanels = panelsCountVertical * panelsCountHorizontal;

    if (totalPanels <= maxPanels) {
      roof.innerHTML = '';
      roof.style.width = roofSizeHorizontal + 'px';
      roof.style.height = roofSizeVertical + 'px';
      
      for (let i = 0; i < panelsCountVertical; i++) {
        for (let j = 0; j < panelsCountHorizontal; j++) {
          const x = j * (panelWidth + panelGap);
          const y = i * (panelHeight + panelGap);
          createPanel(x, y, panelWidth, panelHeight, i + 1, j + 1);
        }
      }

      function createPanel(x, y, width, height, row, column) {
        const panel = document.createElement('div');
        panel.className = 'panel';
        panel.style.width = width + 'px';
        panel.style.height = height + 'px';
        panel.style.left = x + 'px';
        panel.style.top = y + 'px';
        panel.setAttribute('data-x', x);
        panel.setAttribute('data-y', y);
        panel.setAttribute('data-row', row);
        panel.setAttribute('data-column', column);
        roof.appendChild(panel);

        panel.addEventListener('click', function() {
          const panelX = parseInt(panel.getAttribute('data-x'));
          const panelY = parseInt(panel.getAttribute('data-y'));
          const panelRow = parseInt(panel.getAttribute('data-row'));
          const panelColumn = parseInt(panel.getAttribute('data-column'));

          const panelIndex = selectedPanels.findIndex(panel => panel.x === panelX && panel.y === panelY);
          if (panelIndex === -1) {
            selectedPanels.push({ x: panelX, y: panelY, row: panelRow, column: panelColumn });
          } else {
            selectedPanels.splice(panelIndex, 1);
          }
console.log(selectedPanels);

          updateSelectedPanels();
          displayInfo();
        });
		
		
		document.getElementById('material-selection-dropdown').addEventListener('change', function() {
    var selection = this.value;
    var elementsToShow = [];
    var elementsToHide = [];

    if (selection === 'mostki') {
        // Definiuj elementy do pokazania i ukrycia dla opcji "Mostki"
        elementsToShow = ['mostki', 'screws-for-bridges'];
        elementsToHide = ['profiles', 'hmostki', 'double-threads', 'nuts', 'large-screws', 'connectors', 'sheet-metals'];
    } else {
        // Definiuj elementy do pokazania i ukrycia dla opcji "Dach profile"
        elementsToShow = ['profiles', 'double-threads', 'nuts', 'large-screws', 'connectors', 'sheet-metals'];
        elementsToHide = ['mostki', 'screws-for-bridges'];
    }

    // Pokazuj i ukrywaj odpowiednie elementy
    elementsToShow.forEach(function(id) {
        var element = document.getElementById(id);
        if (element) {
            element.style.display = 'block';
        }
    });

    elementsToHide.forEach(function(id) {
        var element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });
});
		
      }

      function updateSelectedPanels() {
        const allPanels = document.querySelectorAll('.panel');
        allPanels.forEach(panel => {
          panel.style.backgroundColor = '';
          panel.id = '';

          const panelX = parseInt(panel.getAttribute('data-x'));
          const panelY = parseInt(panel.getAttribute('data-y'));

          const isSelected = selectedPanels.some(selectedPanel => {
            return selectedPanel.x === panelX && selectedPanel.y === panelY;
          });

          if (isSelected) {
            panel.id = 'elo';
          }
        });
      }
	  
function displayInfo() {

  infoDiv.innerHTML = '';
  summaryDiv.innerHTML = '';
  ssDiv.innerHTML = '';

  const totalLength = selectedPanels.reduce((acc, panel) => acc + panelWidth + panelGap, 0);
  let midClamps = 0;

  selectedPanels.forEach(panel => {
    if (panel.column < panelsCountHorizontal) {
      midClamps += 2;
    }
    if (panel.column === 1 || panel.column === panelsCountHorizontal) {
      midClamps -= 2;
    }
  });



  const rows = Math.ceil(selectedPanels.reduce((acc, panel) => Math.max(acc, panel.row), 0));
  
 // infoDiv.innerHTML += `
 //   <p>Ilość klem środkowych: ${midClamps}</p>
 //   <p>Ilość klem bocznych: ${sideClamps}</p>
 // `;


  function generateCombinations(profiles, maxComboSize) {
    let combinations = [];

    // Dla każdej długości kombinacji od 1 do maxComboSize
    for (let size = 1; size <= maxComboSize; size++) {
        // Start z pustej kombinacji
        let initialCombo = new Array(size).fill(0);
        let stack = [initialCombo];

        while (stack.length > 0) {
            let currentCombo = stack.pop();

            // Jeśli kombinacja jest pełna, dodaj ją do wyników
            if (!currentCombo.includes(0)) {
                combinations.push(currentCombo);
                continue;
            }

            // W przeciwnym razie, dodaj kolejne możliwe wartości
            let nextIndex = currentCombo.indexOf(0);
            for (let profile of profiles) {
                let newCombo = [...currentCombo];
                newCombo[nextIndex] = profile;
                stack.push(newCombo);
            }
        }
    }

    return combinations;
}













  for (let i = 1; i <= rows; i++) {
    const panelsInRow = selectedPanels.filter(panel => panel.row === i);

    let rowLength = panelsInRow.reduce((acc, panel) => acc + panelWidth + panelGap, 0);

    infoDiv.innerHTML += `

    `;

    calculateProfiles(rowLength+2); // Dodaj wywołanie funkcji calculateProfiles() dla każdego rzędu

function calculateProfiles(panelLength) {
  let availableProfiles = [];
  if (document.getElementById('profile-354').checked) availableProfiles.push(354);
  if (document.getElementById('profile-240').checked) availableProfiles.push(240);
  if (document.getElementById('profile-177').checked) availableProfiles.push(177);
  if (document.getElementById('profile-120').checked) availableProfiles.push(120);
      const maxDifference = 500;
      let allCombinations = generateCombinations(availableProfiles, 8); // Generuje kombinacje do 3 profili
  
      // Filtrujemy i sortujemy kombinacje
      let suitableCombinations = allCombinations
          .filter(combo => {
              const totalLength = combo.reduce((acc, val) => acc + val, 0);
              return totalLength >= panelLength && totalLength - panelLength <= maxDifference;
          })
          .sort((a, b) => {
              const totalLengthA = a.reduce((acc, val) => acc + val, 0);
              const totalLengthB = b.reduce((acc, val) => acc + val, 0);
              return (totalLengthA - panelLength) - (totalLengthB - panelLength) || a.length - b.length;
          });
  
      // Wybieramy 5 najlepszych opcji
      let topCombinations = suitableCombinations.slice(0, 1);
  
      // Wyświetlanie wyników
      if (topCombinations.length > 0) {
          topCombinations.forEach((combo, index) => {
  
        
        
        
              let totalLength = combo.reduce((acc, val) => acc + val, 0);
              let profileCount = `2 x (${combo.join('cm + ')}cm)`;
  
        profileCalculations.push({
              panelLength: panelLength,
              totalLength: totalLength,
              profileCount: combo.length * 2,
              profileSizes: combo.join('cm + ')
          });
          let roznica = totalLength - panelLength;
  
  
  
  
                  // Liczba łączników na rząd: (ilość profili - 1) * 2
     // let connectors = (combo.length - 1) * 2;
      //  infoDiv.innerHTML += `
       // <p>${connectors} łączników</p>`;
       if (!summaryDiv) {
        summaryDiv = document.createElement('div');
        summaryDiv.id = 'material-summary';
        document.body.appendChild(summaryDiv);
    }
  
    // Calculations based on selected panels
  
    // Liczba łączników to dwukrotność liczby styków między profilami
    // Jeden styk między dwoma profilami wymaga dwóch łączników

  //////////////////////
    // Displaying the summary
  
  
  // Function to update panel numbers based on selection
  function updatePanelNumbers() {
    const selectedPanels = document.querySelectorAll('.panel.selected');
    selectedPanels.forEach((panel, index) => {
        panel.textContent = index + 1; // Number the panels based on their selection order
    });
  }
  
  function updateMaterialSummary() {
  
    function countOccurrences(combo, target) {
      // Liczymy wystąpienia target w combo
      return combo.reduce((count, number) => count + (number === target ? 2 : 0), 0);
  }
  let profiles354cm = countOccurrences(combo, 354);
  let profiles240cm = countOccurrences(combo, 240);
  let profiles177cm = countOccurrences(combo, 177);
  let profiles120cm = countOccurrences(combo, 120);

  
  function licz_laczniki(combo) {
    // Liczymy wystąpienia target w combo
    return (combo.length - 1)*2;
  }

  function countColumnsWithGaps(selectedPanels) {
    let rows = selectedPanels.reduce((acc, panel) => {
      acc[panel.row] = acc[panel.row] || [];
      acc[panel.row].push(panel.column);
      return acc;
    }, {});
  
    let countResult = {};
    let rowCountResultForRow1 = 0;
    let sideClamps = 0;
    let rowResults = {}; // Obiekt do przechowywania wyników dla poszczególnych rzędów
  
    for (let row in rows) {
      let columns = rows[row];
      columns.sort((a, b) => a - b);
  
      let gapCount = 0;
      for (let i = 0; i < columns.length - 1; i++) {
        if (columns[i + 1] - columns[i] > 1) {
          gapCount++;
        }
      }
  
      countResult[row] = gapCount;
      if (row === '1') {
        rowCountResultForRow1 = gapCount;
      }
  
      let rowsideClamps = 0; // Zmienna dla wyniku danego rzędu
      if (gapCount > 0) {
        rowsideClamps = 4 * gapCount + 4;
      } else {
        rowsideClamps = 4;
      }
      rowResults[row] = rowsideClamps; // Zapis wyniku dla rzędu
      sideClamps += rowsideClamps; // Dodanie do ogólnego wyniku
    }
  
    return { countResult, rowCountResultForRow1, sideClamps, rowResults };
  }
  
  let { countResult, rowCountResultForRow1, sideClamps, rowResults } = countColumnsWithGaps(selectedPanels);
  
  

  

  let connectors = licz_laczniki(combo);
  let newCombo = sumArrayElements(combo);
    const totalPanels = selectedPanels.length;
    const panelPower = 410; // Power per panel in watts
    const panelSize = '172.2 x 113.4 cm'; // Panel size
    let doubleThreads = Math.round(newCombo / 80)*2; // Double threads
    let sheetMetals = doubleThreads; // Sheet metals for double threads
    let largeScrews = doubleThreads; // Large screws
    let nuts = largeScrews; // Nuts
    let midClamps = 0; // Middle clamps
    let screwsForClamps = 0; // Screws for clamps
    let slidesForClamps = 0; // Slides for clamps
    let liczba_paneli = Math.floor(newCombo / panelWidth);

  
  
  



  
  
        let totalProfilesLength = 0;
        let profilesUsed = {};
  
        profileCalculations.forEach(calc => {
            totalProfilesLength += calc.totalLength;
            let profileSizes = calc.profileSizes.split('cm + ');
            profileSizes.forEach(size => {
                profilesUsed[size] = (profilesUsed[size] || 0) + 1;
            });
        });
  
    // Prices in złoty
    const pricePerPanel =300;
    const pricePerDoubleThread = 3.45;
    const pricePerSheetMetal = 1.5;
    const pricePerConnector = 1.5;
    const pricePerLargeScrew = 0.6;
    const pricePerNut = 0.3;
    const pricePerScrewClamp = 0.6;
    const pricePerSlideClamp = 0.6;
    const pricePerSideClamp = 1;
    const pricePerMidClamp = 1;
    const pricePerProfile354cm = 130;
    const pricePerProfile240cm = 60;
    const pricePerProfile120cm = 30;
    const pricePerProfile177cm = 65;
  
    // Calculations for each row of panels
    const rows = Math.ceil(selectedPanels.reduce((acc, panel) => Math.max(acc, panel.row), 0));
    for (let i = 1; i <= rows; i++) {
        const panelsInRow = selectedPanels.filter(panel => panel.row === i);
        let rowLength = panelsInRow.reduce((acc, panel) => {
            if (panel && panel.style && panel.style.width) {
                return acc + parseFloat(panel.style.width);
            }
            return acc;
        }, 0);
  
        // Adding gaps between panels to the total length of the profile
        totalProfilesLength = rowLength + (panelsInRow.length - 1) * 2; // Assuming a 2 cm gap between panels
        midClamps = (liczba_paneli - 1) * 2;
        screwsForClamps = (rowResults[i] + midClamps);
        slidesForClamps = (rowResults[i] + midClamps);
    }
  
    // Calculate the number of profiles needed
    // Calculating costs
    let totalCost = liczba_paneli * pricePerPanel + 
                    doubleThreads * pricePerDoubleThread + 
                    sheetMetals * pricePerSheetMetal + 
                    connectors * pricePerConnector + 
                    largeScrews * pricePerLargeScrew + 
                    nuts * pricePerNut + 
                    screwsForClamps * pricePerScrewClamp + 
                    slidesForClamps * pricePerSlideClamp + 
                    rowResults[i] * pricePerSideClamp + 
                    midClamps * pricePerMidClamp +
                    profiles354cm * pricePerProfile354cm +
                    profiles240cm * pricePerProfile240cm +
                    profiles120cm * pricePerProfile120cm +
                    profiles177cm * pricePerProfile177cm;
  
                    function sumArrayElements(array) {
                      return array.reduce((sum, number) => sum + number, 0);
                  }
                  
                  // Przykładowe użycie

  
  // Wynik
  console.log(rows);
  
        infoDiv.innerHTML += 
       // `<p>Opcja ${index + 1}:<br>
         `
         
         <hr style="height:2px;border-width:0;color:gray;background-color:gray">
    <div class="roww${i}-containter">
      <h1>Rząd ${i}: ${(rowLength+2).toFixed(1)} cm</h1>
    
         <b>Zastosowano profile: ${combo.join('cm + ')}cm </b>dla paneli o długości ${panelLength.toFixed(2)} cm.<br>
         Łączna długość: ${totalLength} cm. <br>
          Użyto łącznie: ${profileCount}.</p>
        <p> Do ucięcia ${roznica.toFixed(2)}cm, czyli po ${roznica.toFixed(2)/2} cm na stronę.</p>
		
		
	  <div class="row${i}-containter">
      <hr style="height:2px;border-width:0;color:gray;background-color:gray">
          <h3>Podsumowanie Materiałów ${i}:</h3>
          <p id="panele">Panele: ${panelSize} ${panelPower} W</p>
          <p>Ilość Paneli: ${liczba_paneli} (${liczba_paneli * pricePerPanel.toFixed(2)} zł)</p>
          <p>Łączna moc instalacji: ${liczba_paneli * panelPower} W</p>
          <p id="double-threads">Dwugwinty: ${doubleThreads} (${doubleThreads * pricePerDoubleThread.toFixed(2)} zł)</p>
          <p id="sheet-metals">Blachy do Dwugwintów: ${sheetMetals} (${sheetMetals * pricePerSheetMetal.toFixed(2)} zł)</p>
          <p id="connectors">Łączniki: ${connectors} (${connectors * pricePerConnector} zł)</p>
          <p id="large-screws">Duże Śruby: ${largeScrews} (${largeScrews.toFixed(2) * pricePerLargeScrew} zł)</p>
          <p id="nuts">Nakrętki: ${nuts} (${nuts * pricePerNut.toFixed(2)} zł)</p>
          <p>Śruby do Klem: ${screwsForClamps} (${screwsForClamps * pricePerScrewClamp.toFixed(2)} zł)</p>
          <p>Ślizgi do Klem: ${slidesForClamps} (${slidesForClamps * pricePerSlideClamp.toFixed(2)} zł)</p>
          <p>Klemy Boczne: ${rowResults[i]} (${rowResults[i] * pricePerSideClamp} zł)</p>
          <p>Klemy Środkowe: ${midClamps} (${midClamps * pricePerMidClamp.toFixed(2)} zł)</p>
          <p id="profiles">Łączna długość profili: ${newCombo*2} cm
          Profil 354cm: ${profiles354cm} (${profiles354cm * pricePerProfile354cm.toFixed(2)} zł) </br>
          Profil 240cm: ${profiles240cm} (${profiles240cm * pricePerProfile240cm.toFixed(2)} zł) </br>
          Profil 177cm: ${profiles177cm} (${profiles177cm * pricePerProfile177cm.toFixed(2)} zł) </br>
          Profil 120cm: ${profiles120cm} (${profiles120cm * pricePerProfile120cm.toFixed(2)} zł) </p>
  
  
          <h2 style="color: green";>Koszt: (${totalCost.toFixed(2)} zł)</h2>
		            <center><div class="roww4-containter" id="overall2-summary"></div></center>
          <center><div class="roww5-containter" id="overall-summary4"></div></center>

		
  </div>

        
        
        
        
        
        
        
        
        `;
  
  
      
  
  
    
      
  
   // Podsumowanie
            let profileSummary = Object.entries(profilesUsed).map(([size, count]) => `${size}cm x ${count} szt.`).join(', ');
      summaryDiv.innerHTML += `


      `;
  footer.innerHTML += 

         `
         

        

        
        
        
        
        
        `;






        function sumParametersInContainers() {
        let sums = {
            aTotalPanels: 0,
            aTotalPanelsCost: 0,
            aTotalCost: 0,
            aTotalPower: 0,
            aTotalDoubleThreads: 0,
            aTotalSheetMetals: 0,
            aTotalConnectors: 0,
            aTotalLargeScrews: 0,
            aTotalNuts: 0,
            aTotalScrewsForClamps: 0,
            aTotalSlidesForClamps: 0,
            aTotalSideClamps: 0,
            aTotalMidClamps: 0,
            aTotalProfileLength: 0,
            aProfileCost: 0,
            aProfiles354cm: 0,
            aProfiles240cm: 0,
            aProfiles177cm: 0,
            aProfiles120cm: 0
            // Dodaj inne potrzebne zmienne
          
        };
    
        // Przechodzenie przez kontenery i sumowanie wartości
        for (let i = 1; i <= 5; i++) { // Zakładamy, że mamy 2 kontenery
            let container = document.querySelector(`div.row${i}-containter`);
            if (!container) continue;
    
            let html = container.innerHTML;
    
            sums.aTotalPanels += extractNumber(html, "Ilość Paneli:");
            sums.aTotalPanelsCost += extractPrice(html, "Ilość Paneli:");
            sums.aTotalCost += extractPrice(html, "Koszt: ");
            sums.aTotalPower += extractNumber(html, "Łączna moc instalacji:");
            sums.aTotalDoubleThreads += extractNumber(html, "Dwugwinty:");
            sums.aTotalSheetMetals += extractNumber(html, "Blachy do Dwugwintów:");
            sums.aTotalConnectors += extractNumber(html, "Łączniki:");
            sums.aTotalLargeScrews += extractNumber(html, "Duże Śruby:");
            sums.aTotalNuts += extractNumber(html, "Nakrętki:");
            sums.aTotalScrewsForClamps += extractNumber(html, "Śruby do Klem:");
            sums.aTotalSlidesForClamps += extractNumber(html, "Ślizgi do Klem:");
            sums.aTotalSideClamps += extractNumber(html, "Klemy Boczne:");
            sums.aTotalMidClamps += extractNumber(html, "Klemy Środkowe:");
            sums.aTotalProfileLength += extractNumber(html, "Łączna długość profili:");
            sums.aProfiles354cm += extractNumber(html, "Profil 354cm:");
            sums.aProfiles240cm += extractNumber(html, "Profil 240cm:");
            sums.aProfiles177cm += extractNumber(html, "Profil 177cm:");
            sums.aProfiles120cm += extractNumber(html, "Profil 120cm:");
            // Dodaj ekstrakcję dla innych kategorii


            
        }
    
    // Funkcja do ekstrakcji liczby z tekstu na podstawie klucza
    function extractNumber(text, key) {
      let regex = new RegExp(key + "\\s*(\\d+(\\.\\d+)?)");
      let match = text.match(regex);
      return match ? parseFloat(match[1]) : 0;
  }

  function extractProfileLength(text, profileType) {
    let regex = new RegExp(`(\\d+)\\s*x\\s*`, "g");
    let match = text.match(regex);
    return match ? parseInt(match[1]) : 0;
}

  // Funkcja do ekstrakcji ceny z tekstu na podstawie klucza
  function extractPrice(text, key) {
      let regex = new RegExp(key + ".*\\((\\d+(\\.\\d+)?)\\s*zł\\)");
      let match = text.match(regex);
      return match ? parseFloat(match[1]) : 0;
  }
    
        // Generowanie nowego HTML z zaktualizowanymi sumami
        document.getElementById('overall-summary').innerHTML = `
        <hr style="height:2px;border-width:0;color:gray;background-color:gray">

            <h3>Podsumowanie Łączne:</h3>
            Łączna moc instalacji: ${sums.aTotalPower} W</br>
            Ilość Paneli: ${sums.aTotalPanels} (${sums.aTotalPanelsCost} zł)</br>
			            Śruby do Klem: ${sums.aTotalScrewsForClamps} (${sums.aTotalScrewsForClamps * pricePerScrewClamp} zł)</br>
            Ślizgi do Klem: ${sums.aTotalSlidesForClamps} (${sums.aTotalSlidesForClamps * pricePerSlideClamp} zł)</br>
            Klemy Boczne: ${sums.aTotalSideClamps} (${sums.aTotalSideClamps * pricePerSideClamp} zł)</br>
            Klemy Środkowe: ${sums.aTotalMidClamps} (${sums.aTotalMidClamps * pricePerMidClamp} zł)</br>
			<div id="mostki" style="display: none"> Mostki: </br>
			Wkręty do mostków: 
			</div>
            <div id="hmostki"> Dwugwinty: ${sums.aTotalDoubleThreads} (${sums.aTotalDoubleThreads * pricePerDoubleThread} zł)</br>
            Blachy do Dwugwintów: ${sums.aTotalSheetMetals} (${sums.aTotalSheetMetals * pricePerSheetMetal} zł)</br>
            Łączniki: ${sums.aTotalConnectors} (${sums.aTotalConnectors * pricePerConnector} zł)</br>
            Duże Śruby: ${sums.aTotalLargeScrews} (${sums.aTotalLargeScrews * pricePerLargeScrew} zł)</br>
            Nakrętki: ${sums.aTotalNuts} (${sums.aTotalNuts * pricePerNut} zł)</br>
            Łączna długość profili: ${sums.aTotalProfileLength} cm</br>
            Profile użyte: </br>${sums.aProfiles354cm} x 354cm (${sums.aProfiles354cm * pricePerProfile354cm} zł) <br>
                 ${sums.aProfiles240cm} x 240cm (${sums.aProfiles240cm * pricePerProfile240cm} zł) <br>
                 ${sums.aProfiles177cm} x 177cm (${sums.aProfiles177cm * pricePerProfile177cm} zł) <br>
                 ${sums.aProfiles120cm} x 120cm (${sums.aProfiles120cm * pricePerProfile120cm} zł)</br> </div>
            <h2 style="color: green;">Całkowity koszt instalacji: ${sums.aTotalCost.toFixed(2)} zł</h2>

    `;



    }
    sumParametersInContainers(); // Wywołanie funkcji









  }
  
  
  
  /////////////////
  

  
  updateMaterialSummary()
  
  //////////////////////////
          });
      } else {


      }
  }


  }








///
  

//tut


// Przykład: Dla combo = [240, 354, 240], calculateConnectors(combo) zwróci 4



}






      }

      


  };

  

// Wywołanie funkcji przy załadowaniu strony
document.addEventListener('DOMContentLoaded', (event) => {
  obliczanie();
});

// Przypisanie funkcji do przycisku
document.getElementById('calculate').addEventListener('click', obliczanie);

window.onload = obliczanie;



});

document.addEventListener('DOMContentLoaded', function() {
  // Funkcja do tworzenia kontenera Flexbox
  function createFlexContainer() {
    const flexContainer = document.createElement('div');
    flexContainer.id = 'flex-container';
    flexContainer.style.display = 'flex';
    flexContainer.style.flexWrap = 'wrap';
    flexContainer.style.justifyContent = 'space-around';
    return flexContainer;
  }

  // Funkcja do przeniesienia rzędów do kontenera Flexbox
  function moveRowsToFlexContainer() {
    const infoDiv = document.getElementById('info');
    if (!infoDiv) return;

    const rowContainers = infoDiv.querySelectorAll('.roww1-containter, .roww2-containter, .roww3-containter');
    const flexContainer = createFlexContainer();

    rowContainers.forEach(container => {
      flexContainer.appendChild(container.cloneNode(true));
      container.remove();
    });

    infoDiv.innerHTML = '';
    infoDiv.appendChild(flexContainer);
  }

  // Dodanie nasłuchiwania na zdarzenia kliknięcia na stronie
  document.addEventListener('click', function() {
    // Opóźnienie potrzebne, aby poczekać na zakończenie generowania rzędów
    setTimeout(moveRowsToFlexContainer, 0);
  });
});

</script>
<script src="update_prices_script.js"></script>
</body>
</html>
